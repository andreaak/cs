using System;
using System.Diagnostics;

namespace CSTest._06_Interface._0_Setup
{
    class BaseClass: IDisposablee
    {
        public void Method()
        {
            Debug.WriteLine("Реализация метода Method() из BaseClass.");
        }


        /*
        Компилятор C# требует, чтобы метод, реализующий интерфейс, отмечался 
        модификатором public. CLR требует, чтобы интерфейсные методы были виртуальными. 
        Если метод явно не определен в коде как виртуальный, компилятор сделает 
        его таковым и, вдобавок, запечатанным. Это не позволяет производному классу 
        переопределять интерфейсные методы. Если явно задать метод как виртуальный, 
        компилятор сделает его таковым и оставит незапечатанным, что предоставит 
        производному классу возможность переопределять интерфейсные методы.
        Производный класс не в состоянии переопределять интерфейсные методы, 
        объявленные запечатанными, но может повторно унаследовать тот же интерфейс 
        и предоставить собственную реализацию его методов. При вызове интерфейсного 
        метода объекта вызывается реализация, связанная с типом самого объекта.
        */

        #region IDisposablee Members

        // Этот метод неявно запечатан и его нельзя переопределить
        public void DisposeNonVirtual()
        {
            Debug.WriteLine("Реализация метода DisposeNonVirtual() в BaseClass");
        }

        public virtual void DisposeVirtual()
        {
            Debug.WriteLine("Реализация метода DisposeVirtual() в BaseClass");
        }

        #endregion
    }
}
