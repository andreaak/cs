using System.Diagnostics;

namespace CSTest._02_Object
{
    /*
    В C# все типы, предопределенные и пользовательские, ссылочные типы и типы значений, 
    наследуют непосредственно или косвенно от Object. 
    Переменным типа object можно назначать значения любых типов.
    
    Так как все классы в платформе .NET Framework являются производными класса Object,
    все методы, определенные в классе Object, доступны для всех объектов в системе.
    В производных классах некоторые из этих методов, включая перечисленные ниже, 
    могут переопределяться и переопределяются: 
    protected Finalize() - данный  метод выполняет операции очистки перед автоматической утилизацией объекта.    
    protected object MemberwiseClone(); - создает "неполную" копию объекта, 
        создает поверхностную копию текущего объекта, а именно он создает новый объект, 
        а затем копирует все нестатические поля текущего объекта в этот новый объект. 
        Если поле имеет тип значения, выполняется копирование разрядной поля. 
        Если же поле относится к ссылочному типу, то копируются ссылки, но не сами объекты, 
        на которые они указывают; следовательно, ссылки в исходном объекте и в его клоне 
        указывают на один и тот же объект.
        Граф наследования клонируется глубоко.
        MemberwiseClone не вызывает конструктор, а копирует дамп памятию.
    public static bool Equals(object objA, object objB) Этот метод справляется с ситуацией, когда обе ссылки равны null, 
        а потому обеспечивает дополнительную защиту от генерации исключений, 
        когда существует риск, что оба объекта окажутся равными null.
    public static bool ReferenceEquals(object objA, object objB) ReferenceEquals() - статический метод, 
        проверяющий, указывают ли две ссылки на один и тот же экземпляр класса; 
        точнее - содержат ли две ссылки один и тот адрес памяти
     */
    class TestClass
    {
        protected int x, y;

        public TestClass(int xValue, int yValue)
        {
            x = xValue;
            y = yValue;
        }

        /*
        public virtual string ToString(); - создает понятную для пользователя строку текста, 
        в которой описывается экземпляр класса.
        */
        public override string ToString()
        {
            return string.Format("TestClass x = {0}; y = {1}", x, y);
        }

        /*
        public virtual bool Equals(object obj); - данный метод поддерживает сравнение объектов.
        */
        public override bool Equals(object obj)
        {
            if (obj == null || this.GetType() != obj.GetType())
                return false;

            TestClass p = (TestClass)obj;
            return (x == p.x) && (y == p.y);
        }
        /*
        public virtual int GetHashCode(); - данный метод создает число, соответствующее значению объекта, 
            обеспечивающее возможность использования хэш-таблицы. 
            Реализация GetHashCode в System.Object ничего «не знает» о производных типах 
            и их полях. Поэтому этот метод возвращает число, однозначно идентифицирующее 
            объект в пределах домена приложений; при этом гарантируется, что это число не 
            изменится на протяжении всей жизни объекта.
        Правило: Переопределяйте GetHashCode переопределяя Equals.
        Выбирая алгоритм вычисления хеш-кодов для экземпляров своего типа, старайтесь следовать определенным правилам:
        - Используйте алгоритм, который дает случайное распределение, повышающее 
            производительность хеш-таблицы. Значения хеш-кода должны распределяться равномерно 
            по всему диапазону чисел, которые может хранить int.
        - Алгоритм может вызывать метод GetHashCode базового типа и использовать 
            возвращаемое им значение, однако в общем случае лучше отказаться от вызова 
            встроенного метода GetHashCode для типа Object или ValueType, так как эти 
            реализации обладают низкой производительностью алгоритмов хеширования.
        - В алгоритме должно использоваться как минимум одно экземплярное поле.
        - Поля, используемые в алгоритме, в идеале не должны изменяться, то есть они 
            должны инициализироваться при создании объекта и сохранять 
            значение в течение всей его жизни.
        - Хеш-код не должен изменяться на протяжении времени существования объекта.
        - Один и тот же объект должен всегда возвращать одно и то же значение.
        - Объекты с одинаковым значением должны возвращать одинаковые коды.
        - Разные объекты могут возвращать одно и то же значение.
        - Алгоритм должен быть максимально быстрым.
        - Он не должен генерировать исключений.
         */
        public override int GetHashCode()
        {
            return x ^ y;
        }
    }

    class BaseClass
    {
        public int age;
        public string name;

        public BaseClass()
        {
            Debug.WriteLine("This is a {0},", GetType());
        }
    }

    class DerivedClass : BaseClass
    {
        public DerivedClass Clone()
        {
            return (DerivedClass)this.MemberwiseClone();
        }
    }


    class A { public int a = 1; }
    class B : A { public int b = 2; }
    class C : B
    {
        public int c = 3;
        public A aa = new A();
    }
    class X : C { }

    class Z : X
    {
        public Z Clone()
        {
            return (Z)this.MemberwiseClone();
        }
    }

    // Клонирование ассоциации происходит поверхностно.

    class A2 { public int a = 1; }
    class B2 { public int b = 2; }
    class C2 { public B2 B = new B2(); }

    class X2
    {
        public A2 A = new A2();
        public C2 C = new C2();
    }

    class Z2 : X2
    {
        // MemberwiseClone() не вызывает конструктор, а копирует дамп памяти
        public Z2 Clone()
        {
            return (Z2)this.MemberwiseClone();
        }
    }
}
